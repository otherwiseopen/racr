% This program and the accompanying materials are made available under the
% terms of the MIT license (X11 license) which accompanies this distribution.

% Author: D. Langner, C. Bürger

\chapter{Evaluation}\label{eval}

Es wurde bereits an dem Anwendungsbeispiel in Kapitel~\ref{anwendungsbeispiel} gezeigt, dass die an die RACR-NET Schnittstelle gesetzten funktionalen Anforderungen von der vorgestellten Implementierung erfüllt werden, insbesondere bezüglich einer benutzerfreundlichen objektorientierten Schnittstelle. Der Zugriff auf Spezifikation und AST-Knoten erfolgt ausschließlich über Instanzen von \csh{Racr.Specification} beziehungsweise \csh{Racr.AstNode} und alle Aufrufe von RACR sind in Methoden dieser Stellvertreter"=Objekte gekapselt.

Im Folgenden soll gezeigt werden, dass RACR-NET nicht nur benutzerfreundlich, sondern auch korrekt und effizient ist.

\section{Testen der Schnittstelle}

Zum Testen von RACR-NET wurde eine umfangreiche, bereits existierende Anwendung\footnote{\url{https://github.com/christoff-buerger/racr/tree/master/examples/questionnaires}}, die den wesentlichen Funktionsumfang RACRs abdeckt, in C\# reimplementiert. Das Beispiel ist eine Lösung des Language Workbench Challenge 2013~\cite{Erdweg2013}, dessen Aufgabe\footnote{\url{http://www.languageworkbenches.net/wp-content/uploads/2013/11/Ql.pdf}} darin bestand, eine domänenspezifische Sprache zu schaffen, mittels welcher interaktive Fragebögen zur Datenerfassung auf einfache Weise beschrieben und ausgewertet werden können. Die Anwendung bedient sich aller Mechanismen RACRs mit Ausnahme von komplexeren Graphersetzungen. Um auch die funktionelle Korrektheit der Graphersetzungsmethoden sicherzustellen, wurden diese in einem eigenen NUnit\footnote{\url{http://www.nunit.org/}}-Test erfasst.

\section{Performance-Messungen und -Vergleiche}

Die Erzeugung von Adapter"=Objekten und der indirekte Zugriff auf RACRs Funktionalitäten über jene Objekte erzeugt einen Laufzeit-Overhead. Dieser wurde für eine RACR"=Anwendung ermittelt, die im Folgenden beschrieben wird.

Unter Verwendung der in Kapitel~\ref{anwendungsbeispiel} gegebenen Sprachspezifikation wurden arithmetische Ausdrücke für verschiedene Konstantenbelegungen berechnet. Um die Ausführungszeiten des C\#-Programms gegenüber denen des Scheme-Programms vergleichen zu können, wurde die Anwendung in beiden Sprachen, Scheme (unter der Verwendung der RACR Scheme-Bibliothek) und C\# (mittels der objektorientierten Schnittstelle), implementiert. Der Laufzeit"=Overhead ist die Differenz der Ausführungszeiten beider Implementierungen in IronScheme. Die den zu berechnenden Ausdruck repräsentierenden ASTs wurden mithilfe eines Python-Skripts generiert und enthalten jeweils 5.000, 10.000 und 20.000 Binär-Operationen und ebenso viele Blatt-Knoten. Die Hälfte der Blatt-Knoten sind Konstanten, wobei insgesamt 26 verschiedene Konstanten-Definitionen benutzt werden.

\begin{table}[h!]
	\centering
	\begin{tabu} to 0.8\textwidth { X[r] X[r] X[r] X[r] X[r] X[r] }
		\toprule
			&&& \multicolumn{3}{c}{Laufzeit in s} \\ \cmidrule(r){4-6}
			Operationen & Evals & Rewrites & C\# & IronScheme & Racket \\
		\midrule
			 5.000 &     1 &     0 &   1,43 &   1,36 &   0,45 \\
			10.000 &     1 &     0 &   2,93 &   2,92 &   0,98 \\
			20.000 &     1 &     0 &   6,21 &   6,03 &   2,17 \\
%			40.000 &     1 &     0 &  12,76 &  12.34 &   4,55 \\
			 5.000 & 1.000 & 1.000 &  72,44 &  72,20 &  24,31 \\
			10.000 & 1.000 & 1.000 & 150,14 & 145,81 &  71,08 \\
			20.000 & 1.000 & 1.000 & 330,58 & 316,97 & 217,79 \\
%			40.000 & 1.000 & 1.000 & 704,30 & 690.11 & 582.17 \\
		\bottomrule
		\end{tabu}
	\caption{Performance-Messungen}
	\label{measurements}
\end{table}

Alle Läufe wurden auf einem Rechner mit einem Intel Core i5-3350P Vier-Kern-Prozessor und 16~GB RAM unter Windows~8.1 gemessen. Das verwendete IronScheme Release war 115404, 32-Bit, vom 29. Oktober 2015. Als .NET VM wurde das Microsoft .NET Framework 4.0 verwendet. Von zwanzig Messungen pro Lauf wurde die beste Zeit genommen. Tabelle~\ref{measurements} zeigt die Messergebnisse für eine einzelne Berechnung des Attributs \scm{'Eval} (Zeile~1 bis 3). Ferner wurden innerhalb einer Schleife jeweils der Wert einer Konstanten in deren Definition modifiziert und anschließend \scm{'Eval} für den Wurzel-Knoten ausgewertet (Zeile~4 bis 6).

Um die Performance von IronScheme gegenüber anderen Scheme-VMs abschätzen zu können, wurden die Tests ebenfalls auf der Racket\footnote{\url{http://racket-lang.org/}} Scheme-VM durchgeführt (Racket Version 6.2). Zur Erfassung des durch die objektorientierte Schnittstelle generierten Overheads sind jedoch lediglich die für IronScheme gemessenen Ausführungszeiten relevant.

Die Messungen ergeben, dass die RACR-NET-Lösung erwartungsgemäß etwas langsamer ausführt als eine reine Scheme"=Lösung. Der Performance-Overhead beträgt für 20.000 Knoten und 1.000 Auswertungen und Graphersetzungen circa 4,3\,\% und ist damit durchaus akzeptabel. Des Weiteren wird ersichtlich, dass IronScheme zwar langsamer ist als Racket, der Faktor jedoch keine Größenordnung beträgt (Im Gegensatz zu Racket ist IronScheme ein Ein-Man-Projekt, bei dem Performance nicht im Mittelpunkt steht).

Bei dem gewählten Beispiel handelt es sich um eine Referenzattributgrammatik, deren Attributsgleichungen auf simple Addition und Multiplikation zweier Fließkommazahlen beschränkt sind. Es bleibt daher zu untersuchen, wie stark der Geschwindigkeitsvorteil von C\# gegenüber IronScheme in komplexeren Gleichungen zum Tragen kommt und, ob dieser den Overhead von RACR-NET wohl möglich kompensiert.

Die Messergebnisse unterstreichen die Vorteile der RAG-gesteuerten Graphersetzung. Eine einmalige Auswertung von \scm{'Eval} ist relativ teuer (1,43 Sekunden mittels RACR-NET), weil anfangs alle Attribut-Caches leer sind und so \scm{'Eval} erst für jeden Teilausdruck berechnet werden muss. Da die vorgenommenen Graphersetzungen nur jeweils einen Anteil der zuvor berechneten Attributwerte invalidieren, begünstigt die inkrementelle Auswertung alle nachträglichen Berechnungen. Eintausend Berechnungen mit intermediären Graphersetzungen benötigen 330,58 Sekunden – nur circa 20\,\% der tausendfachen Dauer der initiale Berechnung.
